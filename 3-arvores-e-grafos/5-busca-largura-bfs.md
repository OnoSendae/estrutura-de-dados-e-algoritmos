# Busca em Largura (BFS) em Grafos

## üåä Introdu√ß√£o √† Busca em Largura

A Busca em Largura (BFS - Breadth-First Search) √© um dos algoritmos fundamentais para explorar grafos. Como o nome sugere, o algoritmo explora o grafo "em largura", visitando todos os vizinhos de um v√©rtice antes de avan√ßar para os vizinhos dos vizinhos.

## üß† Intui√ß√£o e Abordagem

Imagine que voc√™ est√° em um labirinto e quer explorar todas as passagens poss√≠veis:

1. Voc√™ marca sua posi√ß√£o inicial como visitada
2. Voc√™ olha todas as passagens diretamente conectadas √† sua posi√ß√£o e as coloca em uma lista
3. Uma a uma, voc√™ segue cada passagem na lista, marcando como visitada e adicionando novas passagens n√£o visitadas √† sua lista

Essa abordagem garante que voc√™ encontre o caminho mais curto (em n√∫mero de passos) para qualquer ponto do labirinto.

## üéØ Como o BFS Funciona

O BFS utiliza uma **fila** para controlar a ordem de explora√ß√£o dos v√©rtices. A propriedade fundamental da fila (FIFO - First In, First Out) garante que os v√©rtices sejam processados em ordem crescente de dist√¢ncia da origem.

### Algoritmo B√°sico

1. Inicialize uma fila vazia e insira o v√©rtice de origem
2. Marque o v√©rtice de origem como visitado
3. Enquanto a fila n√£o estiver vazia:
   a. Retire um v√©rtice da fila (o "atual")
   b. Processe o v√©rtice atual (e.g., imprima, conte, verifique uma condi√ß√£o)
   c. Obtenha todos os vizinhos n√£o visitados do v√©rtice atual
   d. Marque cada vizinho como visitado e adicione-o √† fila

### Visualiza√ß√£o Passo a Passo

Para o grafo:
```
    A --- B
   / \    |
  C   D -- E
   \     /
    \   /
     \ /
      F
```

BFS come√ßando do v√©rtice A:

```
Passo 1: Fila = [A], Visitados = {A}
Passo 2: Processar A, Fila = [B, C, D], Visitados = {A, B, C, D}
Passo 3: Processar B, Fila = [C, D, E], Visitados = {A, B, C, D, E}
Passo 4: Processar C, Fila = [D, E, F], Visitados = {A, B, C, D, E, F}
Passo 5: Processar D, Fila = [E, F], Visitados = {A, B, C, D, E, F}
Passo 6: Processar E, Fila = [F], Visitados = {A, B, C, D, E, F}
Passo 7: Processar F, Fila = [], Visitados = {A, B, C, D, E, F}
```

Ordem de visita√ß√£o: A, B, C, D, E, F

Observe que visitamos todos os v√©rtices √† dist√¢ncia 1 de A (B, C, D) antes de qualquer v√©rtice √† dist√¢ncia 2 (E, F).

## üíª Implementa√ß√£o em JavaScript

### BFS B√°sico

```javascript
function bfs(graph, startVertex) {
    // Estruturas de controle
    const visited = new Set();
    const queue = [startVertex];
    const result = [];
    
    // Marca o v√©rtice inicial como visitado
    visited.add(startVertex);
    
    // Enquanto a fila n√£o estiver vazia
    while (queue.length > 0) {
        // Remove o primeiro v√©rtice da fila
        const currentVertex = queue.shift();
        
        // Processa o v√©rtice atual
        result.push(currentVertex);
        
        // Obt√©m vizinhos do v√©rtice atual
        const neighbors = graph.getNeighbors(currentVertex);
        
        // Para cada vizinho n√£o visitado
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return result;
}
```

### BFS para Encontrar o Caminho Mais Curto

```javascript
function shortestPath(graph, startVertex, endVertex) {
    // Se origem e destino s√£o iguais
    if (startVertex === endVertex) {
        return [startVertex];
    }
    
    // Estruturas de controle
    const visited = new Set();
    const queue = [[startVertex, [startVertex]]]; // [v√©rtice, caminho at√© ele]
    
    visited.add(startVertex);
    
    while (queue.length > 0) {
        const [currentVertex, path] = queue.shift();
        const neighbors = graph.getNeighbors(currentVertex);
        
        for (let neighbor of neighbors) {
            // Se encontramos o destino
            if (neighbor === endVertex) {
                return [...path, neighbor]; // Retorna o caminho completo
            }
            
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, [...path, neighbor]]);
            }
        }
    }
    
    return null; // N√£o h√° caminho entre os v√©rtices
}
```

### BFS para Computar Dist√¢ncias

```javascript
function distances(graph, startVertex) {
    const visited = new Set();
    const queue = [[startVertex, 0]]; // [v√©rtice, dist√¢ncia]
    const distances = {};
    
    visited.add(startVertex);
    distances[startVertex] = 0;
    
    while (queue.length > 0) {
        const [currentVertex, distance] = queue.shift();
        const neighbors = graph.getNeighbors(currentVertex);
        
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                distances[neighbor] = distance + 1;
                queue.push([neighbor, distance + 1]);
            }
        }
    }
    
    return distances;
}
```

### BFS para Verificar Biparti√ß√£o

Um grafo √© bipartido se seus v√©rtices podem ser divididos em dois conjuntos, de forma que todas as arestas conectem v√©rtices de conjuntos diferentes.

```javascript
function isBipartite(graph) {
    const vertices = [...graph.adjacencyList.keys()];
    if (vertices.length === 0) return true;
    
    // Colors: -1 = n√£o visitado, 0 = conjunto A, 1 = conjunto B
    const colors = {};
    vertices.forEach(v => colors[v] = -1);
    
    for (let vertex of vertices) {
        // Se o v√©rtice n√£o foi visitado
        if (colors[vertex] === -1) {
            // Inicializa como conjunto A
            colors[vertex] = 0;
            
            const queue = [vertex];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = graph.getNeighbors(current);
                
                for (let neighbor of neighbors) {
                    // Se o vizinho n√£o foi visitado
                    if (colors[neighbor] === -1) {
                        // Atribui a cor oposta
                        colors[neighbor] = 1 - colors[current];
                        queue.push(neighbor);
                    } 
                    // Se o vizinho j√° foi visitado e tem a mesma cor
                    else if (colors[neighbor] === colors[current]) {
                        return false; // N√£o √© bipartido
                    }
                }
            }
        }
    }
    
    return true;
}
```

## üìä An√°lise de Complexidade

| Opera√ß√£o | Complexidade Temporal | Complexidade Espacial |
|----------|----------------------|----------------------|
| BFS b√°sico | O(V + E) | O(V) |
| Caminho mais curto | O(V + E) | O(V) |
| Computar dist√¢ncias | O(V + E) | O(V) |
| Verificar biparti√ß√£o | O(V + E) | O(V) |

Onde V √© o n√∫mero de v√©rtices e E √© o n√∫mero de arestas.

## üõ†Ô∏è Aplica√ß√µes Pr√°ticas do BFS

### 1. Redes Sociais

**Problema**: Encontrar todos os usu√°rios dentro de K graus de conex√£o.

```javascript
function findUsersWithinDegrees(graph, startUser, maxDegrees) {
    const visited = new Set();
    const queue = [[startUser, 0]]; // [usu√°rio, dist√¢ncia]
    const result = [];
    
    visited.add(startUser);
    
    while (queue.length > 0) {
        const [user, degree] = queue.shift();
        
        if (degree <= maxDegrees) {
            result.push(user);
            
            if (degree < maxDegrees) {
                const friends = graph.getNeighbors(user);
                
                for (let friend of friends) {
                    if (!visited.has(friend)) {
                        visited.add(friend);
                        queue.push([friend, degree + 1]);
                    }
                }
            }
        }
    }
    
    return result;
}
```

### 2. Sistemas de Navega√ß√£o

**Problema**: Encontrar todas as localiza√ß√µes acess√≠veis dentro de um limite de tempo/dist√¢ncia.

```javascript
function findLocationsWithinDistance(graph, startLocation, maxDistance) {
    const visited = new Set();
    const queue = [[startLocation, 0]]; // [localiza√ß√£o, dist√¢ncia]
    const reachableLocations = [];
    
    visited.add(startLocation);
    
    while (queue.length > 0) {
        const [location, distance] = queue.shift();
        
        if (distance <= maxDistance) {
            reachableLocations.push(location);
            
            const neighbors = graph.getNeighbors(location);
            
            for (let [neighbor, weight] of neighbors) {
                const newDistance = distance + weight;
                
                if (!visited.has(neighbor) && newDistance <= maxDistance) {
                    visited.add(neighbor);
                    queue.push([neighbor, newDistance]);
                }
            }
        }
    }
    
    return reachableLocations;
}
```

### 3. Verifica√ß√£o de Conectividade

**Problema**: Verificar se dois componentes de um circuito est√£o conectados.

```javascript
function isConnected(graph, component1, component2) {
    const visited = new Set();
    const queue = [component1];
    
    visited.add(component1);
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (current === component2) {
            return true;
        }
        
        const neighbors = graph.getNeighbors(current);
        
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
            }
        }
    }
    
    return false;
}
```

### 4. Verifica√ß√£o de Bicolora√ß√£o (Problema de Colora√ß√£o)

**Problema**: Verificar se um grafo pode ser colorido usando apenas duas cores.

```javascript
function isTwoColorable(graph) {
    return isBipartite(graph); // Este √© exatamente o problema de biparti√ß√£o
}
```

## üîÑ BFS vs. DFS

| Aspecto | BFS | DFS |
|---------|-----|-----|
| Estrat√©gia | Explora√ß√£o em largura | Explora√ß√£o em profundidade |
| Estrutura de dados | Fila | Pilha |
| Encontra caminho mais curto | Sim (em grafos n√£o ponderados) | N√£o |
| Uso de mem√≥ria | Maior (mant√©m a fronteira) | Menor (proporcional √† profundidade) |
| Bom para | Encontrar dist√¢ncias, explorar n√≠vel a n√≠vel | Percorrer caminhos completos, detec√ß√£o de ciclos |
| Implementa√ß√£o | Iterativa (geralmente) | Recursiva ou iterativa |

## üß© Varia√ß√µes e Otimiza√ß√µes

### 1. BFS Bidirecional

Executa duas BFS simultaneamente: uma da origem e outra do destino, melhorando a efici√™ncia em grafos grandes.

```javascript
function bidirectionalBFS(graph, start, end) {
    if (start === end) return [start];
    
    const forwardVisited = new Map();
    const backwardVisited = new Map();
    
    const forwardQueue = [start];
    const backwardQueue = [end];
    
    forwardVisited.set(start, null); // valor = antecessor
    backwardVisited.set(end, null);
    
    let intersection = null;
    
    while (forwardQueue.length > 0 && backwardQueue.length > 0) {
        // Expande a fronteira para frente
        if (forwardQueue.length <= backwardQueue.length) {
            const current = forwardQueue.shift();
            const neighbors = graph.getNeighbors(current);
            
            for (let neighbor of neighbors) {
                if (!forwardVisited.has(neighbor)) {
                    forwardVisited.set(neighbor, current);
                    forwardQueue.push(neighbor);
                    
                    if (backwardVisited.has(neighbor)) {
                        intersection = neighbor;
                        break;
                    }
                }
            }
        } 
        // Expande a fronteira para tr√°s
        else {
            const current = backwardQueue.shift();
            const neighbors = graph.getNeighbors(current);
            
            for (let neighbor of neighbors) {
                if (!backwardVisited.has(neighbor)) {
                    backwardVisited.set(neighbor, current);
                    backwardQueue.push(neighbor);
                    
                    if (forwardVisited.has(neighbor)) {
                        intersection = neighbor;
                        break;
                    }
                }
            }
        }
        
        if (intersection !== null) {
            // Reconstr√≥i o caminho
            const path = [intersection];
            
            // Adiciona o caminho para frente
            let current = intersection;
            while (forwardVisited.get(current) !== null) {
                current = forwardVisited.get(current);
                path.unshift(current);
            }
            
            // Adiciona o caminho para tr√°s
            current = intersection;
            while (backwardVisited.get(current) !== null) {
                current = backwardVisited.get(current);
                path.push(current);
            }
            
            return path;
        }
    }
    
    return null; // N√£o h√° caminho
}
```

### 2. BFS com Prioridade

Uma varia√ß√£o que combina BFS com uma fila de prioridade, √∫til para grafos ponderados.

```javascript
function priorityBFS(graph, start, end, priorityFunction) {
    const visited = new Set();
    const priorityQueue = new PriorityQueue();
    
    priorityQueue.enqueue([start, [start]], priorityFunction(start));
    visited.add(start);
    
    while (!priorityQueue.isEmpty()) {
        const [current, path] = priorityQueue.dequeue().value;
        
        if (current === end) {
            return path;
        }
        
        const neighbors = graph.getNeighbors(current);
        
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                const newPath = [...path, neighbor];
                visited.add(neighbor);
                priorityQueue.enqueue([neighbor, newPath], priorityFunction(neighbor));
            }
        }
    }
    
    return null;
}
```

## üß† Liga√ß√£o com Estruturas Anteriores

A implementa√ß√£o de BFS depende fortemente da estrutura de dados **fila**, que estudamos no m√≥dulo anterior sobre estruturas lineares. A fila √© perfeita para BFS porque mant√©m a ordem de processamento dos v√©rtices por n√≠veis.

Na pr√≥xima aula, exploraremos a Busca em Profundidade (DFS), que usa a estrat√©gia oposta √† BFS e √© implementada naturalmente com recurs√£o ou com a estrutura de dados **pilha**. 