# Fundamentos de Estruturas de Dados Persistentes e Imut√°veis

## üîÑ Revis√£o de Conceitos Fundamentais

Antes de mergulharmos nas estruturas de dados persistentes, vamos revisar brevemente os conceitos fundamentais de √°rvores que j√° estudamos:

```ascii
√Årvore Bin√°ria B√°sica       √Årvore Bin√°ria de Busca
      A                           50
     / \                         /  \
    B   C                       30   70
   / \                         / \   / \
  D   E                       20 40 60  80
```

Nas estruturas de dados tradicionais (mut√°veis), quando realizamos opera√ß√µes como inser√ß√£o ou remo√ß√£o, modificamos a estrutura original. Isso pode causar problemas em ambientes concorrentes ou quando precisamos manter o hist√≥rico de altera√ß√µes.

## üéØ Objetivos de Aprendizagem

- Compreender os fundamentos te√≥ricos de estruturas de dados persistentes e imut√°veis
- Entender o valor da imutabilidade em contextos de programa√ß√£o funcional e concorrente
- Implementar vers√µes persistentes de √°rvores bin√°rias de busca
- Aplicar √°rvores persistentes em cen√°rios que requerem hist√≥rico de vers√µes
- Analisar a complexidade de tempo e espa√ßo dessas estruturas
- Comparar estruturas persistentes com suas contrapartes mut√°veis

## üìö Introdu√ß√£o √†s Estruturas Persistentes

As estruturas de dados persistentes representam um paradigma poderoso que permite manter o hist√≥rico completo de modifica√ß√µes, onde cada opera√ß√£o cria uma nova vers√£o da estrutura sem modificar as vers√µes anteriores.

### Conceito de Persist√™ncia

```ascii
               Original
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                   ‚îÇ
  Vers√£o ap√≥s      Vers√£o ap√≥s
  adicionar 5     remover 10
        ‚îÇ                   ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ        ‚îÇ          ‚îÇ        ‚îÇ
   ‚ñº        ‚ñº          ‚ñº        ‚ñº
  ...      ...        ...      ...
```

A persist√™ncia em estruturas de dados pode ser classificada em diferentes n√≠veis:

1. **Persist√™ncia Parcial**: Permite consultar qualquer vers√£o anterior, mas s√≥ permite modifica√ß√µes na vers√£o mais recente.
2. **Persist√™ncia Total**: Permite consultas e modifica√ß√µes em qualquer vers√£o.
3. **Persist√™ncia Confluente**: Al√©m da persist√™ncia total, permite combinar diferentes vers√µes.
4. **Persist√™ncia Funcional**: Todas as opera√ß√µes criam novas vers√µes sem modificar as existentes.

### Compara√ß√£o com Estruturas Mut√°veis

| Caracter√≠stica | Estrutura Mut√°vel | Estrutura Persistente |
|----------------|-------------------|------------------------|
| Estado | √önico estado que muda | M√∫ltiplos estados imut√°veis |
| Hist√≥rico | N√£o mant√©m | Preserva todas as vers√µes |
| Concorr√™ncia | Precisa de locks | Naturalmente thread-safe |
| Mem√≥ria | Mais eficiente | Requer mais espa√ßo |
| Depura√ß√£o | Mais complexa | Mais simples |

### Por que Usar Estruturas Persistentes?

- **Desfazer/Refazer**: Facilita implementa√ß√£o de opera√ß√µes de desfazer/refazer em editores.
- **Depura√ß√£o**: Permite examinar o estado anterior quando um problema ocorre.
- **Concorr√™ncia**: Simplifica o racioc√≠nio sobre c√≥digo concorrente eliminando estados compartilhados mut√°veis.
- **Algoritmos Incrementais**: Permite testar diferentes caminhos sem duplicar toda a estrutura.
- **Programa√ß√£o Funcional**: Fundamental para linguagens funcionais puras.

## üå≥ √Årvores Bin√°rias de Busca Persistentes

Uma √°rvore bin√°ria de busca persistente permite que voc√™ acesse qualquer vers√£o anterior ap√≥s inser√ß√µes, exclus√µes ou atualiza√ß√µes.

### Implementa√ß√£o B√°sica

Vamos implementar uma BST persistente simples em TypeScript:

```typescript
interface TreeNode<T> {
    value: T;
    left: TreeNode<T> | null;
    right: TreeNode<T> | null;
}

class PersistentBST<T> {
    root: TreeNode<T> | null;
    
    constructor(root: TreeNode<T> | null = null) {
        this.root = root;
    }
    
    // Insere um valor e retorna uma nova √°rvore
    insert(value: T): PersistentBST<T> {
        const newRoot = this.insertNode(this.root, value);
        return new PersistentBST(newRoot);
    }
    
    private insertNode(node: TreeNode<T> | null, value: T): TreeNode<T> {
        // Se o n√≥ √© nulo, cria um novo n√≥
        if (node === null) {
            return { value, left: null, right: null };
        }
        
        // Cria um novo n√≥ com os mesmos valores
        const newNode: TreeNode<T> = { ...node };
        
        // Decide em qual sub√°rvore inserir
        if (value < node.value) {
            newNode.left = this.insertNode(node.left, value);
        } else if (value > node.value) {
            newNode.right = this.insertNode(node.right, value);
        }
        
        // Retorna o novo n√≥ (raiz da sub√°rvore)
        return newNode;
    }
    
    // Encontra um valor
    find(value: T): boolean {
        return this.findInNode(this.root, value);
    }
    
    private findInNode(node: TreeNode<T> | null, value: T): boolean {
        if (node === null) return false;
        if (node.value === value) return true;
        
        if (value < node.value) {
            return this.findInNode(node.left, value);
        } else {
            return this.findInNode(node.right, value);
        }
    }
    
    // Remove um valor e retorna uma nova √°rvore
    remove(value: T): PersistentBST<T> {
        const newRoot = this.removeNode(this.root, value);
        return new PersistentBST(newRoot);
    }
    
    private removeNode(node: TreeNode<T> | null, value: T): TreeNode<T> | null {
        if (node === null) return null;
        
        // Cria um novo n√≥ para preservar o original
        let newNode: TreeNode<T> = { ...node };
        
        if (value < node.value) {
            newNode.left = this.removeNode(node.left, value);
        } else if (value > node.value) {
            newNode.right = this.removeNode(node.right, value);
        } else {
            // Caso 1: N√≥ folha
            if (node.left === null && node.right === null) {
                return null;
            }
            
            // Caso 2: N√≥ com apenas um filho
            if (node.left === null) {
                return node.right;
            }
            if (node.right === null) {
                return node.left;
            }
            
            // Caso 3: N√≥ com dois filhos
            // Encontrar o sucessor (menor valor na sub√°rvore direita)
            const successor = this.findMin(node.right);
            newNode.value = successor.value;
            
            // Remover o sucessor da sub√°rvore direita
            newNode.right = this.removeNode(node.right, successor.value);
        }
        
        return newNode;
    }
    
    private findMin(node: TreeNode<T>): TreeNode<T> {
        let current = node;
        while (current.left !== null) {
            current = current.left;
        }
        return current;
    }

    // M√©todo adicional para percorrer a √°rvore em ordem
    inOrderTraversal(): T[] {
        const result: T[] = [];
        this.inOrderTraversalNode(this.root, result);
        return result;
    }
    
    private inOrderTraversalNode(node: TreeNode<T> | null, result: T[]): void {
        if (node === null) return;
        
        this.inOrderTraversalNode(node.left, result);
        result.push(node.value);
        this.inOrderTraversalNode(node.right, result);
    }
}
```

### Exemplo de Uso

```typescript
// Criar uma √°rvore vazia
const emptyTree = new PersistentBST<number>();

// Inserir elementos e criar novas vers√µes
const version1 = emptyTree.insert(10);
const version2 = version1.insert(5);
const version3 = version2.insert(15);
const version4 = version3.insert(3);

// Vers√£o alternativa derivada de version3
const altVersion = version3.insert(7);

// Remover um elemento
const version5 = version4.remove(5);

// Podemos acessar todas as vers√µes
console.log("version1 cont√©m 5?", version1.find(5)); // false
console.log("version2 cont√©m 5?", version2.find(5)); // true
console.log("version5 cont√©m 5?", version5.find(5)); // false (removido)
console.log("altVersion cont√©m 7?", altVersion.find(7)); // true

// Visualiza√ß√£o da evolu√ß√£o
console.log("version1:", version1.inOrderTraversal()); // [10]
console.log("version2:", version2.inOrderTraversal()); // [5, 10]
console.log("version3:", version3.inOrderTraversal()); // [5, 10, 15]
console.log("version4:", version4.inOrderTraversal()); // [3, 5, 10, 15]
console.log("version5:", version5.inOrderTraversal()); // [3, 10, 15]
console.log("altVersion:", altVersion.inOrderTraversal()); // [5, 7, 10, 15]
```

### Visualiza√ß√£o da Evolu√ß√£o das Vers√µes

```ascii
version1:         version2:         version3:         version4:         version5:
   10                10                10                10                10
                    /                 / \               / \               / \
                   5                 5   15            5   15            3   15
                                                     /
                                                    3

altVersion:
    10
   /  \
  5    15
   \
    7
```

## üöÄ T√©cnicas de Otimiza√ß√£o para Persist√™ncia

### Path Copying (C√≥pia de Caminho)

A t√©cnica que usamos acima √© chamada "path copying", onde somente o caminho da raiz at√© o n√≥ modificado √© copiado.

```ascii
         Original               Nova Vers√£o
            10                      10*
           /  \                    /  \
          5   15        ‚Üí         5*  15
         / \                     / \
        3   7                   3   8*
```

No diagrama acima, apenas os n√≥s marcados com asterisco (*) s√£o novos. Isso economiza espa√ßo significativo em compara√ß√£o com duplicar toda a √°rvore.

#### Exemplo Detalhado de Path Copying - Inser√ß√£o do valor 8

```ascii
Passo 1: Estado original
         10
        /  \
       5    15
      / \
     3   7

Passo 2: Come√ßa a inser√ß√£o, cria c√≥pia da raiz
         10*
        /  \
       5    15
      / \
     3   7

Passo 3: Desce para o n√≥ 5, cria c√≥pia
         10*
        /  \
       5*   15
      / \
     3   7

Passo 4: Desce para o n√≥ 7, cria c√≥pia e insere 8
         10*
        /  \
       5*   15
      / \
     3   7*
          \
           8

Resultado final: Apenas os n√≥s no caminho foram copiados (10*, 5*, 7*)
```

### Fat Nodes (N√≥s Gordos)

Uma abordagem alternativa para estruturas persistentes √© usar "fat nodes", onde cada n√≥ mant√©m um hist√≥rico de modifica√ß√µes:

```typescript
interface Version {
    id: number;
    timestamp: number;
}

interface FatNode<T> {
    value: T;
    versions: Version[];
    left: Map<number, FatNode<T> | null>;  // vers√£o -> n√≥ esquerdo
    right: Map<number, FatNode<T> | null>; // vers√£o -> n√≥ direito
}

class FatNodeBST<T> {
    private root: FatNode<T> | null;
    private currentVersion: number;
    
    constructor() {
        this.root = null;
        this.currentVersion = 0;
    }
    
    // Cria uma nova vers√£o e retorna seu ID
    private createNewVersion(): number {
        return ++this.currentVersion;
    }
    
    // Insere um valor na vers√£o atual e retorna a nova vers√£o
    insert(value: T): number {
        const newVersion = this.createNewVersion();
        this.root = this.insertNode(this.root, value, newVersion);
        return newVersion;
    }
    
    private insertNode(node: FatNode<T> | null, value: T, version: number): FatNode<T> {
        if (node === null) {
            // Cria um novo n√≥
            return {
                value,
                versions: [{ id: version, timestamp: Date.now() }],
                left: new Map(),
                right: new Map()
            };
        }
        
        if (value < node.value) {
            // Adiciona filho √† esquerda para esta vers√£o
            const leftChild = this.insertNode(
                node.left.get(this.getLatestVersionBefore(node.left, version)) || null,
                value,
                version
            );
            node.left.set(version, leftChild);
        } else if (value > node.value) {
            // Adiciona filho √† direita para esta vers√£o
            const rightChild = this.insertNode(
                node.right.get(this.getLatestVersionBefore(node.right, version)) || null,
                value,
                version
            );
            node.right.set(version, rightChild);
        }
        
        // Registra esta vers√£o no n√≥
        node.versions.push({ id: version, timestamp: Date.now() });
        return node;
    }
    
    // Obt√©m a vers√£o mais recente menor ou igual √† vers√£o especificada
    private getLatestVersionBefore(versionMap: Map<number, any>, version: number): number {
        let latestVersion = -1;
        for (const v of versionMap.keys()) {
            if (v <= version && v > latestVersion) {
                latestVersion = v;
            }
        }
        return latestVersion;
    }
    
    // Encontra um valor em uma vers√£o espec√≠fica
    find(value: T, version: number): boolean {
        return this.findInNode(this.root, value, version);
    }
    
    private findInNode(node: FatNode<T> | null, value: T, version: number): boolean {
        if (node === null) return false;
        
        // Verifica se o n√≥ existia na vers√£o especificada
        const nodeVersion = node.versions.find(v => v.id <= version);
        if (!nodeVersion) return false;
        
        if (node.value === value) return true;
        
        if (value < node.value) {
            const leftChildVersion = this.getLatestVersionBefore(node.left, version);
            if (leftChildVersion === -1) return false;
            return this.findInNode(node.left.get(leftChildVersion) || null, value, version);
        } else {
            const rightChildVersion = this.getLatestVersionBefore(node.right, version);
            if (rightChildVersion === -1) return false;
            return this.findInNode(node.right.get(rightChildVersion) || null, value, version);
        }
    }
}
```

#### Visualiza√ß√£o do Conceito de Fat Nodes

```ascii
Fat Node (mant√©m valores para v√°rias vers√µes):

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Valor: 10                     ‚îÇ
‚îÇ                               ‚îÇ
‚îÇ Vers√µes:                      ‚îÇ
‚îÇ  - v1 (timestamp: 1001)       ‚îÇ
‚îÇ  - v2 (timestamp: 1005)       ‚îÇ
‚îÇ  - v4 (timestamp: 1015)       ‚îÇ
‚îÇ                               ‚îÇ
‚îÇ Esquerda:                     ‚îÇ
‚îÇ  - v1 ‚Üí null                  ‚îÇ
‚îÇ  - v2 ‚Üí N√≥[5]                 ‚îÇ
‚îÇ  - v4 ‚Üí N√≥[5]                 ‚îÇ
‚îÇ                               ‚îÇ
‚îÇ Direita:                      ‚îÇ
‚îÇ  - v1 ‚Üí null                  ‚îÇ
‚îÇ  - v2 ‚Üí null                  ‚îÇ
‚îÇ  - v4 ‚Üí N√≥[15]                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### An√°lise de Complexidade

- **Espa√ßo com Path Copying**: O(log n) adicional por opera√ß√£o
- **Espa√ßo com Fat Nodes**: O(n + m) onde n √© o n√∫mero de n√≥s e m o n√∫mero de modifica√ß√µes
- **Tempo para Path Copying**: O(log n) para opera√ß√µes padr√£o da BST
- **Tempo para Fat Nodes**: O(log n + log v) onde v √© o n√∫mero de vers√µes

## üåü Aplica√ß√µes Pr√°ticas

### 1. Controle de Vers√£o em Editores de Texto

Os editores de texto modernos usam estruturas persistentes para manter o hist√≥rico de edi√ß√µes:

```typescript
class TextEditor {
    private versions: PersistentBST<string>[] = [];
    private currentVersion = 0;
    
    constructor(initialText: string) {
        const lines = initialText.split('\n');
        let tree = new PersistentBST<string>();
        
        // Inserir cada linha na √°rvore com o n√∫mero da linha como chave
        for (let i = 0; i < lines.length; i++) {
            tree = tree.insert(lines[i]);
        }
        
        this.versions.push(tree);
    }
    
    editLine(lineNumber: number, newText: string) {
        // Cria uma nova vers√£o a partir da atual
        const newTree = this.versions[this.currentVersion].remove(lineNumber);
        const updatedTree = newTree.insert(newText);
        
        // Adiciona a nova vers√£o e atualiza o ponteiro
        this.versions.push(updatedTree);
        this.currentVersion++;
    }
    
    undo() {
        if (this.currentVersion > 0) {
            this.currentVersion--;
        }
    }
    
    redo() {
        if (this.currentVersion < this.versions.length - 1) {
            this.currentVersion++;
        }
    }
}
```

### 2. Estruturas Funcionais para Programa√ß√£o Concorrente

As estruturas persistentes s√£o ideais para sistemas concorrentes, pois eliminam a necessidade de bloqueios:

```typescript
// Worker thread processar dados sem bloqueios
function processDataConcurrently(data: PersistentBST<number>) {
    // Cada thread pode criar sua pr√≥pria vers√£o
    const localVersion = data.insert(threadLocalValue);
    
    // Processa usando a vers√£o local
    const result = process(localVersion);
    
    // Combina resultados sem conflitos
    return mergeResults(result);
}
```

### 3. Explora√ß√£o de Espa√ßo de Estados em IA

Algoritmos de busca em IA podem usar estruturas persistentes para explorar diferentes caminhos:

```typescript
function alphaBetaPruning(gameState: PersistentGameTree, depth: number): number {
    if (depth === 0) return evaluate(gameState);
    
    const possibleMoves = gameState.getValidMoves();
    
    let bestValue = -Infinity;
    for (const move of possibleMoves) {
        // Cria um novo estado sem modificar o original
        const newState = gameState.applyMove(move);
        
        const value = -alphaBetaPruning(newState, depth - 1);
        bestValue = Math.max(bestValue, value);
    }
    
    return bestValue;
}
```

## üìà Considera√ß√µes sobre Performance

### Vantagens
- Opera√ß√µes desfazer/refazer em tempo constante
- Facilita concorr√™ncia e paralelismo
- Simplifica o racioc√≠nio sobre o c√≥digo

### Desvantagens
- Maior consumo de mem√≥ria (apesar das otimiza√ß√µes)
- Poss√≠vel overhead em opera√ß√µes simples
- Complexidade da implementa√ß√£o

### Benchmarking

Compara√ß√£o de desempenho entre BST mut√°vel e persistente em diferentes opera√ß√µes:

```ascii
                  ‚îÇ Inser√ß√£o   ‚îÇ Busca      ‚îÇ Remo√ß√£o    ‚îÇ Mem√≥ria
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
BST Mut√°vel       ‚îÇ O(log n)   ‚îÇ O(log n)   ‚îÇ O(log n)   ‚îÇ O(n)
BST Persistente   ‚îÇ O(log n)   ‚îÇ O(log n)   ‚îÇ O(log n)   ‚îÇ O(n + v log n)
(Path Copying)    ‚îÇ            ‚îÇ            ‚îÇ            ‚îÇ
BST Persistente   ‚îÇ O(log n)   ‚îÇ O(log n+v) ‚îÇ O(log n)   ‚îÇ O(n + m)
(Fat Nodes)       ‚îÇ            ‚îÇ            ‚îÇ            ‚îÇ

onde:
  n = n√∫mero de elementos
  v = n√∫mero de vers√µes
  m = n√∫mero de modifica√ß√µes
```

## üîÑ Compara√ß√£o com Estruturas Mut√°veis

| Aspecto | Estruturas Persistentes | Estruturas Tradicionais |
|---------|-------------------------|-------------------------|
| Mem√≥ria | Maior uso | Menor uso |
| Concorr√™ncia | Excelente | Requer sincroniza√ß√£o |
| Hist√≥rico | Nativo | Necessita implementa√ß√£o extra |
| Complexidade | Maior | Menor |
| Debug | Mais f√°cil | Mais dif√≠cil |
| Racioc√≠nio | Mais simples | Mais complexo |
| Reutiliza√ß√£o | Alta | Baixa |

## üéØ Exerc√≠cios Pr√°ticos

### Exerc√≠cios B√°sicos
1. Implemente uma fun√ß√£o que verifica se duas vers√µes diferentes de uma BST persistente s√£o iguais.
2. Adicione um m√©todo para calcular a altura de uma BST persistente em uma vers√£o espec√≠fica.
3. Modifique a implementa√ß√£o para contar quantos n√≥s foram realmente criados durante uma opera√ß√£o de inser√ß√£o.

### Exerc√≠cios Intermedi√°rios
4. Implemente um m√©todo que combina duas vers√µes diferentes de uma BST persistente.
5. Adicione balanceamento (AVL ou Red-Black) √† nossa BST persistente.
6. Crie uma tabela hash persistente baseada em √°rvores.

### Exerc√≠cios Avan√ßados
7. Construa um editor de texto simples com hist√≥rico usando estruturas persistentes.
8. Implemente um sistema de controle de vers√£o simplificado para arquivos.
9. Compare o desempenho de √°rvores persistentes vs. tradicionais em diferentes cen√°rios.

## ‚ùì Perguntas Frequentes

1. **Quando devo usar estruturas persistentes em vez de estruturas mut√°veis?**
   - Use estruturas persistentes quando precisar manter hist√≥rico de altera√ß√µes, trabalhar em ambiente concorrente, ou implementar funcionalidades de desfazer/refazer.

2. **As estruturas persistentes s√£o sempre mais lentas?**
   - N√£o necessariamente. Embora existam overheads, em cen√°rios concorrentes elas podem ser mais r√°pidas por eliminarem a necessidade de locks.

3. **Como escolher entre Path Copying e Fat Nodes?**
   - Use Path Copying para melhor desempenho em opera√ß√µes comuns e menor overhead de mem√≥ria por opera√ß√£o. Use Fat Nodes quando o n√∫mero de vers√µes for muito alto.

4. **As estruturas persistentes s√£o usadas em sistemas reais?**
   - Sim! Sistemas como Git, bancos de dados como Datomic, bibliotecas como Immutable.js, e frameworks como React usam conceitos de persist√™ncia.

## üîó Recursos Adicionais

- [Purely Functional Data Structures](https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) por Chris Okasaki
- [Making Data Structures Persistent](https://www.cs.cmu.edu/~sleator/papers/making-data-structures-persistent.pdf) por Driscoll et al.
- Bibliotecas: Immutable.js, Immer para JavaScript/TypeScript
- [Persistent Data Structures in JavaScript](https://github.com/funkia/list) - Implementa√ß√£o de lista funcional
- [Understanding Persistence](https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2) - Artigo sobre compartilhamento estrutural

---

Na pr√≥xima aula, exploraremos listas encadeadas persistentes, adaptando os conceitos aprendidos aqui para estruturas lineares. 