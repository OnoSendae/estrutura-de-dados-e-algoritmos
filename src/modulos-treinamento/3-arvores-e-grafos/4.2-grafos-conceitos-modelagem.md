# Modelagem de Problemas Usando Grafos

## üß© A Arte de Transformar Problemas em Grafos

Uma das habilidades mais valiosas na ci√™ncia da computa√ß√£o √© a capacidade de modelar problemas complexos como grafos. Muitos problemas aparentemente dif√≠ceis se tornam trat√°veis quando representados como opera√ß√µes em grafos.

## üöÄ Processo de Modelagem

Para modelar um problema usando grafos, siga estes passos:

1. **Identifique as entidades**: O que pode ser representado como v√©rtices?
2. **Identifique as rela√ß√µes**: Que conex√µes existem entre as entidades?
3. **Determine o tipo de grafo**: Dirigido ou n√£o-dirigido? Ponderado ou n√£o?
4. **Estabele√ßa a sem√¢ntica**: O que significa a exist√™ncia de um caminho? O que representa um ciclo?
5. **Escolha os algoritmos**: Quais algoritmos de grafos resolvem o problema modelado?

Vamos aplicar este processo a problemas do mundo real.

## üí° Estudos de Caso

### 1. Sistema de Navega√ß√£o GPS

**Problema**: Encontrar o caminho mais curto ou mais r√°pido entre dois pontos.

**Modelagem**:
- **V√©rtices**: Cruzamentos, pontos de interesse, entroncamentos
- **Arestas**: Ruas, estradas, avenidas
- **Pesos**: Dist√¢ncia, tempo de viagem, tr√°fego
- **Tipo de Grafo**: Dirigido (ruas de m√£o √∫nica) e ponderado
- **Algoritmos**: Dijkstra, A*, Bellman-Ford

```javascript
class NavigationSystem {
    constructor() {
        this.graph = new AdjacencyList(true, true); // Grafo dirigido e ponderado
    }
    
    addLocation(locationId) {
        this.graph.addVertex(locationId);
    }
    
    addRoad(from, to, distance, travelTime) {
        this.graph.addEdge(from, to, { 
            distance, 
            travelTime,
            trafficMultiplier: 1.0 // Fator para ajuste de tr√°fego em tempo real
        });
    }
    
    updateTraffic(from, to, trafficLevel) {
        // Encontra a aresta e atualiza o multiplicador de tr√°fego
        const edges = this.graph.adjacencyList.get(from);
        for (let edge of edges) {
            if (edge.vertex === to) {
                edge.weight.trafficMultiplier = trafficLevel;
                break;
            }
        }
    }
    
    findFastestRoute(start, end) {
        // Implementa√ß√£o do algoritmo de Dijkstra
        // usando tempo de viagem ajustado pelo tr√°fego
        return this._dijkstra(start, end, 'travelTime');
    }
    
    findShortestRoute(start, end) {
        // Implementa√ß√£o do algoritmo de Dijkstra
        // usando dist√¢ncia
        return this._dijkstra(start, end, 'distance');
    }
    
    _dijkstra(start, end, weightProperty) {
        // Implementa√ß√£o b√°sica do algoritmo de Dijkstra
        // Detalhes omitidos para brevidade
    }
}
```

**Visualiza√ß√£o**:
```
         5km/5min          2km/3min
    [A] -----------> [B] -----------> [C]
     |                |                 ^
     |                |                 |
     | 2km/2min       | 3km/4min        | 4km/4min
     |                |                 |
     v                v                 |
    [D] -----------> [E] --------------+
         3km/3min
```

### 2. Rede Social

**Problema**: Sugerir amigos, encontrar conex√µes, calcular graus de separa√ß√£o.

**Modelagem**:
- **V√©rtices**: Usu√°rios
- **Arestas**: Amizades ou conex√µes
- **Tipo de Grafo**: N√£o-dirigido (amizades) ou dirigido (seguir)
- **Algoritmos**: BFS, componentes conectados, centralidade

```javascript
class SocialNetwork {
    constructor() {
        this.friendshipGraph = new AdjacencyList(false); // N√£o-dirigido para amizades
        this.followGraph = new AdjacencyList(true); // Dirigido para "seguir"
    }
    
    addUser(userId) {
        this.friendshipGraph.addVertex(userId);
        this.followGraph.addVertex(userId);
    }
    
    addFriendship(user1, user2) {
        this.friendshipGraph.addEdge(user1, user2);
    }
    
    addFollow(follower, followed) {
        this.followGraph.addEdge(follower, followed);
    }
    
    // Sugest√£o de amigos: amigos de amigos que n√£o s√£o seus amigos
    suggestFriends(userId, maxSuggestions = 5) {
        const friends = this.friendshipGraph.getNeighbors(userId);
        const suggestions = new Map(); // Mapa para contar ocorr√™ncias
        
        for (let friend of friends) {
            const friendsOfFriend = this.friendshipGraph.getNeighbors(friend);
            
            for (let potential of friendsOfFriend) {
                // Ignora usu√°rios que j√° s√£o amigos ou o pr√≥prio usu√°rio
                if (potential !== userId && !friends.includes(potential)) {
                    suggestions.set(
                        potential, 
                        (suggestions.get(potential) || 0) + 1
                    );
                }
            }
        }
        
        // Ordena sugest√µes pelo n√∫mero de amigos em comum (descendente)
        return [...suggestions.entries()]
            .sort((a, b) => b[1] - a[1])
            .slice(0, maxSuggestions)
            .map(entry => entry[0]);
    }
    
    // Calcula graus de separa√ß√£o entre dois usu√°rios (dist√¢ncia no grafo)
    degreesOfSeparation(user1, user2) {
        if (user1 === user2) return 0;
        
        const visited = new Set([user1]);
        const queue = [[user1, 0]]; // [usu√°rio, dist√¢ncia]
        
        while (queue.length > 0) {
            const [current, distance] = queue.shift();
            const friends = this.friendshipGraph.getNeighbors(current);
            
            for (let friend of friends) {
                if (friend === user2) {
                    return distance + 1;
                }
                
                if (!visited.has(friend)) {
                    visited.add(friend);
                    queue.push([friend, distance + 1]);
                }
            }
        }
        
        return -1; // N√£o h√° caminho
    }
}
```

**Visualiza√ß√£o**:
```
    [Alice] --- [Bob] --- [Charlie]
       |          |
       |          |
    [David] --- [Eve] --- [Frank]
       |                    |
       |                    |
    [Grace] ---------------- 
```

### 3. Sistema de Depend√™ncias de Software

**Problema**: Gerenciar depend√™ncias, detectar conflitos, determinar ordem de compila√ß√£o.

**Modelagem**:
- **V√©rtices**: M√≥dulos, pacotes ou classes
- **Arestas**: Depend√™ncias (A depende de B)
- **Tipo de Grafo**: Dirigido (DAG idealmente)
- **Algoritmos**: Ordena√ß√£o topol√≥gica, detec√ß√£o de ciclos

```javascript
class DependencyManager {
    constructor() {
        this.dependencyGraph = new AdjacencyList(true); // Grafo dirigido
    }
    
    addModule(moduleId) {
        this.dependencyGraph.addVertex(moduleId);
    }
    
    addDependency(module, dependsOn) {
        this.dependencyGraph.addEdge(module, dependsOn);
    }
    
    // Detecta ciclos de depend√™ncia (problema cr√≠tico)
    hasCyclicDependencies() {
        const visited = new Set();
        const recursionStack = new Set();
        const vertices = [...this.dependencyGraph.adjacencyList.keys()];
        
        for (let vertex of vertices) {
            if (this._hasCycle(vertex, visited, recursionStack)) {
                return true;
            }
        }
        
        return false;
    }
    
    _hasCycle(vertex, visited, recursionStack) {
        if (!visited.has(vertex)) {
            visited.add(vertex);
            recursionStack.add(vertex);
            
            const neighbors = this.dependencyGraph.getNeighbors(vertex);
            for (let neighbor of neighbors) {
                if (!visited.has(neighbor) && this._hasCycle(neighbor, visited, recursionStack)) {
                    return true;
                } else if (recursionStack.has(neighbor)) {
                    return true;
                }
            }
        }
        
        recursionStack.delete(vertex);
        return false;
    }
    
    // Gera ordem de compila√ß√£o (ordena√ß√£o topol√≥gica)
    getBuildOrder() {
        if (this.hasCyclicDependencies()) {
            throw new Error("Cannot determine build order with cyclic dependencies");
        }
        
        const result = [];
        const visited = new Set();
        const vertices = [...this.dependencyGraph.adjacencyList.keys()];
        
        for (let vertex of vertices) {
            if (!visited.has(vertex)) {
                this._topologicalSort(vertex, visited, result);
            }
        }
        
        return result.reverse();
    }
    
    _topologicalSort(vertex, visited, result) {
        visited.add(vertex);
        
        const neighbors = this.dependencyGraph.getNeighbors(vertex);
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                this._topologicalSort(neighbor, visited, result);
            }
        }
        
        result.push(vertex);
    }
}
```

**Visualiza√ß√£o**:
```
    [App] ------> [UI] --------> [Graphics]
      |             |               ^
      |             |               |
      v             v               |
    [Core] ------> [Utils] ---------+
      |              ^
      |              |
      +------------> [Logger]
```

### 4. Escalonamento de Tarefas

**Problema**: Alocar recursos, planejar execu√ß√£o, minimizar tempo total.

**Modelagem**:
- **V√©rtices**: Tarefas
- **Arestas**: Depend√™ncias, restri√ß√µes de ordem
- **Pesos**: Tempo de execu√ß√£o, prioridade
- **Tipo de Grafo**: Dirigido e ponderado
- **Algoritmos**: Caminho cr√≠tico, ordena√ß√£o topol√≥gica

```javascript
class TaskScheduler {
    constructor() {
        this.taskGraph = new AdjacencyList(true, true); // Dirigido e ponderado
    }
    
    addTask(taskId, duration) {
        this.taskGraph.addVertex(taskId);
        // Armazenamos a dura√ß√£o como propriedade do v√©rtice
        this.taskGraph.adjacencyList.get(taskId).duration = duration;
    }
    
    addDependency(task, dependsOn) {
        this.taskGraph.addEdge(task, dependsOn, 0); // Peso 0 para a aresta
    }
    
    // Calcula o caminho cr√≠tico (sequ√™ncia de tarefas que determina o tempo m√≠nimo total)
    findCriticalPath() {
        const topOrder = this.getTopologicalOrder();
        const earliestStart = new Map();
        
        // Inicializa todos os in√≠cios mais cedo como 0
        for (let task of this.taskGraph.adjacencyList.keys()) {
            earliestStart.set(task, 0);
        }
        
        // Calcula o in√≠cio mais cedo para cada tarefa
        for (let i = 0; i < topOrder.length; i++) {
            const task = topOrder[i];
            const dependencies = this.taskGraph.getNeighbors(task);
            
            for (let dep of dependencies) {
                const depEnd = earliestStart.get(dep) + this.taskGraph.adjacencyList.get(dep).duration;
                earliestStart.set(task, Math.max(earliestStart.get(task), depEnd));
            }
        }
        
        // Encontra o tempo total de projeto
        let maxEnd = 0;
        for (let task of this.taskGraph.adjacencyList.keys()) {
            const taskEnd = earliestStart.get(task) + this.taskGraph.adjacencyList.get(task).duration;
            maxEnd = Math.max(maxEnd, taskEnd);
        }
        
        // Identifica tarefas no caminho cr√≠tico
        const criticalPath = [];
        for (let task of this.taskGraph.adjacencyList.keys()) {
            // Um tarefa est√° no caminho cr√≠tico se seu atraso impacta o projeto total
            if (earliestStart.get(task) + this.taskGraph.adjacencyList.get(task).duration === maxEnd) {
                criticalPath.push(task);
            }
        }
        
        return {
            criticalPath,
            totalTime: maxEnd
        };
    }
    
    getTopologicalOrder() {
        const result = [];
        const visited = new Set();
        const vertices = [...this.taskGraph.adjacencyList.keys()];
        
        for (let vertex of vertices) {
            if (!visited.has(vertex)) {
                this._topologicalSort(vertex, visited, result);
            }
        }
        
        return result.reverse();
    }
    
    _topologicalSort(vertex, visited, result) {
        visited.add(vertex);
        
        const neighbors = this.taskGraph.getNeighbors(vertex);
        for (let neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                this._topologicalSort(neighbor, visited, result);
            }
        }
        
        result.push(vertex);
    }
}
```

**Visualiza√ß√£o**:
```
    [Funda√ß√£o (7d)] --> [Estrutura (14d)] --> [Telhado (3d)] --> [Finaliza√ß√£o (7d)]
          |                    |                                      ^
          |                    |                                      |
          |                    +------------> [Instala√ß√µes (8d)] ------+
          |                                         ^
          +-----------------> [Encanamento (5d)] ---+
```

## üîç Problemas Cl√°ssicos Modelados com Grafos

### 1. Problema do Caminho Mais Curto

**Defini√ß√£o**: Encontrar o caminho com a menor soma de pesos entre dois v√©rtices.

**Aplica√ß√µes**:
- Sistemas de navega√ß√£o
- Roteamento de rede
- Log√≠stica e distribui√ß√£o

**Algoritmos**:
- **Dijkstra**: Para grafos com pesos n√£o-negativos
- **Bellman-Ford**: Para grafos que podem ter pesos negativos
- **A***: Quando h√° uma heur√≠stica para estimar a dist√¢ncia at√© o destino

### 2. Problema da √Årvore Geradora M√≠nima

**Defini√ß√£o**: Encontrar um subconjunto de arestas que forma uma √°rvore incluindo todos os v√©rtices, com a menor soma de pesos.

**Aplica√ß√µes**:
- Design de redes (minimizar custos de cabos)
- Agrupamento de dados (clustering)
- Aproxima√ß√µes para problemas NP-dif√≠ceis

**Algoritmos**:
- **Kruskal**: Constr√≥i a √°rvore escolhendo as arestas mais leves
- **Prim**: Cresce a √°rvore a partir de um v√©rtice inicial

### 3. Problema de Fluxo M√°ximo

**Defini√ß√£o**: Determinar o fluxo m√°ximo poss√≠vel em uma rede com capacidades nas arestas.

**Aplica√ß√µes**:
- Redes de distribui√ß√£o
- Aloca√ß√£o de recursos
- Matching bipartido

**Algoritmos**:
- **Ford-Fulkerson**
- **Edmonds-Karp**
- **Dinic**

### 4. Problema do Caixeiro Viajante

**Defini√ß√£o**: Encontrar o ciclo mais curto que visita cada v√©rtice exatamente uma vez.

**Aplica√ß√µes**:
- Planejamento de rotas
- Sequenciamento de DNA
- Log√≠stica

**Algoritmos**:
- Algoritmos exatos (programa√ß√£o din√¢mica, branch and bound)
- Heur√≠sticas (2-opt, 3-opt)
- Meta-heur√≠sticas (algoritmos gen√©ticos, col√¥nia de formigas)

## üîÑ Do Problema ao Algoritmo: Exemplos

### Exemplo 1: Jogo "Seis Graus de Separa√ß√£o"

**Problema**: Determinar o menor n√∫mero de "passos" para conectar duas celebridades (ou atores).

**Modelagem**:
- **V√©rtices**: Celebridades/atores
- **Arestas**: Trabalharam juntos
- **Algoritmo**: BFS para encontrar o caminho mais curto

### Exemplo 2: Sistema de Recomenda√ß√£o

**Problema**: Recomendar produtos para usu√°rios com base em prefer√™ncias similares.

**Modelagem**:
- **V√©rtices**: Usu√°rios e produtos (grafo bipartido)
- **Arestas**: Compras/avalia√ß√µes
- **Algoritmo**: Propaga√ß√£o de similaridade, passeio aleat√≥rio

### Exemplo 3: Detec√ß√£o de Comunidades

**Problema**: Identificar grupos em redes sociais.

**Modelagem**:
- **V√©rtices**: Usu√°rios
- **Arestas**: Conex√µes sociais
- **Algoritmo**: Detec√ß√£o de comunidades (Louvain, Girvan-Newman)

## üí° Dicas para Modelagem Eficiente

1. **Identifique claramente o problema a ser resolvido**
   - Quais s√£o as perguntas espec√≠ficas que precisam ser respondidas?

2. **Minimize a complexidade do grafo**
   - Inclua apenas os v√©rtices e arestas necess√°rios
   - Considere usar m√∫ltiplos grafos para diferentes aspectos

3. **Escolha a representa√ß√£o adequada**
   - Lista de adjac√™ncia para grafos esparsos
   - Matriz de adjac√™ncia para grafos densos e opera√ß√µes frequentes de verifica√ß√£o

4. **Preste aten√ß√£o √† dire√ß√£o das arestas**
   - A dire√ß√£o geralmente representa rela√ß√µes assim√©tricas ou fluxo

5. **Use pesos significativos**
   - Os pesos devem representar alguma m√©trica relevante para o problema
   - Considere m√∫ltiplos pesos se necess√°rio 