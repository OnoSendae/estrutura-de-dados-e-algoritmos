# Representa√ß√µes Computacionais de Grafos

## üß© Por que Diferentes Representa√ß√µes?

A escolha da representa√ß√£o adequada para um grafo √© crucial para a efici√™ncia dos algoritmos que o manipulam. Diferentes representa√ß√µes t√™m diferentes vantagens e desvantagens em termos de:

1. **Consumo de mem√≥ria**
2. **Efici√™ncia de opera√ß√µes** (adicionar/remover arestas, verificar adjac√™ncia)
3. **Facilidade de implementa√ß√£o**
4. **Adequa√ß√£o a certos algoritmos**

## üìä Principais Representa√ß√µes

Vamos explorar as representa√ß√µes mais comuns de grafos e suas implementa√ß√µes em JavaScript.

### 1. Matriz de Adjac√™ncia

Uma matriz bidimensional onde a posi√ß√£o [i][j] indica se existe uma aresta entre os v√©rtices i e j.

#### Visualiza√ß√£o

Para o grafo:
```
    A --- B
    |     |
    |     |
    C --- D
```

A matriz de adjac√™ncia correspondente (considerando v√©rtices 0=A, 1=B, 2=C, 3=D):

```
    A  B  C  D
A [ 0, 1, 1, 0 ]
B [ 1, 0, 0, 1 ]
C [ 1, 0, 0, 1 ]
D [ 0, 1, 1, 0 ]
```

#### Implementa√ß√£o em JavaScript

```javascript
class AdjacencyMatrix {
    constructor(numVertices) {
        this.numVertices = numVertices;
        this.matrix = Array(numVertices).fill()
            .map(() => Array(numVertices).fill(0));
    }
    
    // Adiciona uma aresta n√£o-dirigida
    addEdge(v1, v2) {
        this.matrix[v1][v2] = 1;
        this.matrix[v2][v1] = 1; // Para grafo n√£o-dirigido
    }
    
    // Adiciona uma aresta dirigida
    addDirectedEdge(from, to) {
        this.matrix[from][to] = 1;
    }
    
    // Adiciona uma aresta ponderada
    addWeightedEdge(v1, v2, weight) {
        this.matrix[v1][v2] = weight;
        this.matrix[v2][v1] = weight; // Para grafo n√£o-dirigido
    }
    
    // Remove uma aresta
    removeEdge(v1, v2) {
        this.matrix[v1][v2] = 0;
        this.matrix[v2][v1] = 0;
    }
    
    // Verifica se existe aresta
    hasEdge(v1, v2) {
        return this.matrix[v1][v2] !== 0;
    }
    
    // Obt√©m todos os vizinhos de um v√©rtice
    getNeighbors(vertex) {
        const neighbors = [];
        for (let i = 0; i < this.numVertices; i++) {
            if (this.matrix[vertex][i] !== 0) {
                neighbors.push(i);
            }
        }
        return neighbors;
    }
    
    // Imprime a matriz
    print() {
        console.log("Matriz de Adjac√™ncia:");
        for (let i = 0; i < this.numVertices; i++) {
            console.log(this.matrix[i].join(" "));
        }
    }
}

// Exemplo de uso
const graph = new AdjacencyMatrix(4);
graph.addEdge(0, 1); // A-B
graph.addEdge(0, 2); // A-C
graph.addEdge(1, 3); // B-D
graph.addEdge(2, 3); // C-D
graph.print();
```

#### An√°lise de Complexidade

| Opera√ß√£o | Complexidade |
|----------|------------|
| Espa√ßo   | O(V¬≤)      |
| Adicionar Aresta | O(1) |
| Remover Aresta   | O(1) |
| Verificar Aresta | O(1) |
| Obter Vizinhos   | O(V) |

#### Vantagens e Desvantagens

**Vantagens:**
- Implementa√ß√£o simples
- Verifica√ß√£o de exist√™ncia de aresta em O(1)
- Remo√ß√£o de aresta em O(1)
- Adequada para grafos densos

**Desvantagens:**
- Uso de mem√≥ria O(V¬≤) mesmo para grafos esparsos
- Ineficiente para grafos grandes e esparsos
- Adi√ß√£o/remo√ß√£o de v√©rtices requer realocar a matriz

### 2. Lista de Adjac√™ncia

Uma cole√ß√£o de listas, onde cada lista cont√©m os vizinhos de um v√©rtice espec√≠fico.

#### Visualiza√ß√£o

Para o mesmo grafo anterior:

```
A: [B, C]
B: [A, D]
C: [A, D]
D: [B, C]
```

#### Implementa√ß√£o em JavaScript

```javascript
class AdjacencyList {
    constructor(isDirected = false, isWeighted = false) {
        this.adjacencyList = new Map();
        this.isDirected = isDirected;
        this.isWeighted = isWeighted;
    }
    
    // Adiciona um v√©rtice
    addVertex(vertex) {
        if (!this.adjacencyList.has(vertex)) {
            this.adjacencyList.set(vertex, []);
        }
    }
    
    // Adiciona uma aresta
    addEdge(v1, v2, weight = null) {
        // Garante que os v√©rtices existam
        this.addVertex(v1);
        this.addVertex(v2);
        
        // Adiciona a aresta
        if (this.isWeighted) {
            this.adjacencyList.get(v1).push({ vertex: v2, weight });
            if (!this.isDirected) {
                this.adjacencyList.get(v2).push({ vertex: v1, weight });
            }
        } else {
            this.adjacencyList.get(v1).push(v2);
            if (!this.isDirected) {
                this.adjacencyList.get(v2).push(v1);
            }
        }
    }
    
    // Remove uma aresta
    removeEdge(v1, v2) {
        if (this.adjacencyList.has(v1)) {
            this.adjacencyList.set(v1, 
                this.adjacencyList.get(v1).filter(v => 
                    (typeof v === 'object' ? v.vertex : v) !== v2));
        }
        
        if (!this.isDirected && this.adjacencyList.has(v2)) {
            this.adjacencyList.set(v2, 
                this.adjacencyList.get(v2).filter(v => 
                    (typeof v === 'object' ? v.vertex : v) !== v1));
        }
    }
    
    // Remove um v√©rtice
    removeVertex(vertex) {
        if (!this.adjacencyList.has(vertex)) return;
        
        // Remove todas as arestas para este v√©rtice
        for (let v of this.adjacencyList.keys()) {
            this.removeEdge(v, vertex);
        }
        
        // Remove o v√©rtice
        this.adjacencyList.delete(vertex);
    }
    
    // Verifica se existe aresta
    hasEdge(v1, v2) {
        if (!this.adjacencyList.has(v1)) return false;
        
        return this.adjacencyList.get(v1).some(v => 
            (typeof v === 'object' ? v.vertex : v) === v2);
    }
    
    // Obt√©m todos os vizinhos de um v√©rtice
    getNeighbors(vertex) {
        if (!this.adjacencyList.has(vertex)) return [];
        
        return this.adjacencyList.get(vertex).map(v => 
            typeof v === 'object' ? v.vertex : v);
    }
    
    // Imprime a lista de adjac√™ncia
    print() {
        for (let [vertex, edges] of this.adjacencyList.entries()) {
            let edgeString;
            
            if (this.isWeighted) {
                edgeString = edges.map(e => `${e.vertex}(${e.weight})`).join(", ");
            } else {
                edgeString = edges.join(", ");
            }
            
            console.log(`${vertex} -> ${edgeString}`);
        }
    }
}

// Exemplo de uso
const graph = new AdjacencyList();
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');
graph.addEdge('C', 'D');
graph.print();
```

#### An√°lise de Complexidade

| Opera√ß√£o | Complexidade |
|----------|------------|
| Espa√ßo   | O(V + E)   |
| Adicionar Aresta | O(1) |
| Remover Aresta   | O(E) ou O(grau(v)) |
| Verificar Aresta | O(E) ou O(grau(v)) |
| Obter Vizinhos   | O(1) para acessar a lista, O(grau(v)) para copiar |

#### Vantagens e Desvantagens

**Vantagens:**
- Eficiente em espa√ßo para grafos esparsos (O(V + E))
- Adi√ß√£o de v√©rtices √© f√°cil
- Itera√ß√£o sobre os vizinhos de um v√©rtice √© eficiente
- Mais apropriada para a maioria dos algoritmos de grafos

**Desvantagens:**
- Verifica√ß√£o de exist√™ncia de aresta √© O(grau(v))
- Menos eficiente para grafos muito densos
- Remo√ß√£o de aresta requer varredura da lista de adjac√™ncia

### 3. Matriz de Incid√™ncia

Uma matriz onde as linhas representam v√©rtices e as colunas representam arestas. O valor [i][j] indica se o v√©rtice i est√° conectado √† aresta j.

#### Visualiza√ß√£o

Para o grafo anterior com 4 v√©rtices (A,B,C,D) e 4 arestas (AB, AC, BD, CD):

```
    AB AC BD CD
A [ 1, 1, 0, 0 ]
B [ 1, 0, 1, 0 ]
C [ 0, 1, 0, 1 ]
D [ 0, 0, 1, 1 ]
```

#### Implementa√ß√£o em JavaScript

```javascript
class IncidenceMatrix {
    constructor(numVertices) {
        this.numVertices = numVertices;
        this.numEdges = 0;
        this.matrix = Array(numVertices).fill()
            .map(() => []);
        this.edgeMap = new Map(); // Mapeia pares de v√©rtices para √≠ndices de arestas
    }
    
    // Adiciona uma aresta n√£o-dirigida
    addEdge(v1, v2) {
        const edgeIndex = this.numEdges++;
        this.edgeMap.set(`${Math.min(v1,v2)},${Math.max(v1,v2)}`, edgeIndex);
        
        // Expande as linhas da matriz para acomodar a nova aresta
        for (let i = 0; i < this.numVertices; i++) {
            this.matrix[i][edgeIndex] = 0;
        }
        
        this.matrix[v1][edgeIndex] = 1;
        this.matrix[v2][edgeIndex] = 1;
    }
    
    // Adiciona uma aresta dirigida
    addDirectedEdge(from, to) {
        const edgeIndex = this.numEdges++;
        this.edgeMap.set(`${from},${to}`, edgeIndex);
        
        // Expande as linhas da matriz para acomodar a nova aresta
        for (let i = 0; i < this.numVertices; i++) {
            this.matrix[i][edgeIndex] = 0;
        }
        
        this.matrix[from][edgeIndex] = 1;  // Sa√≠da
        this.matrix[to][edgeIndex] = -1;   // Entrada
    }
    
    // Verifica se existe aresta
    hasEdge(v1, v2) {
        const key = `${Math.min(v1,v2)},${Math.max(v1,v2)}`;
        return this.edgeMap.has(key);
    }
    
    // Imprime a matriz
    print() {
        console.log("Matriz de Incid√™ncia:");
        for (let i = 0; i < this.numVertices; i++) {
            console.log(this.matrix[i].join(" "));
        }
    }
}
```

#### An√°lise de Complexidade

| Opera√ß√£o | Complexidade |
|----------|------------|
| Espa√ßo   | O(V √ó E)   |
| Adicionar Aresta | O(V) |
| Verificar Aresta | O(1) com mapeamento |
| Obter Incid√™ncias | O(E) |

#### Vantagens e Desvantagens

**Vantagens:**
- √ötil para analisar propriedades de arestas
- Boa para multigrafos (m√∫ltiplas arestas entre os mesmos v√©rtices)
- Adequada para algoritmos que manipulam arestas

**Desvantagens:**
- Consome mais mem√≥ria que a lista de adjac√™ncia para grafos esparsos
- Menos eficiente para algoritmos que exploram vizinhan√ßa
- Adi√ß√£o de arestas √© O(V)

## üîÑ Compara√ß√£o Entre Representa√ß√µes

| Aspecto | Matriz de Adjac√™ncia | Lista de Adjac√™ncia | Matriz de Incid√™ncia |
|---------|----------------------|---------------------|----------------------|
| Espa√ßo | O(V¬≤) | O(V + E) | O(V √ó E) |
| Verificar aresta | O(1) | O(grau(v)) | O(1) com mapeamento |
| Adicionar aresta | O(1) | O(1) | O(V) |
| Remover aresta | O(1) | O(grau(v)) | O(V) |
| Adicionar v√©rtice | O(V¬≤) | O(1) | O(E) |
| Remover v√©rtice | O(V¬≤) | O(V + E) | O(E) |
| Obter vizinhos | O(V) | O(grau(v)) | O(E) |
| Melhor para | Grafos densos | Grafos esparsos | An√°lise de arestas |
| Acesso √† mem√≥ria | Sequencial | N√£o-sequencial | Sequencial por v√©rtice |

## üíª Escolhendo a Representa√ß√£o Adequada

### Use Matriz de Adjac√™ncia quando:
- O grafo for denso (muitas arestas)
- Precisar verificar rapidamente se existe aresta entre dois v√©rtices
- O n√∫mero de v√©rtices for pequeno e relativamente constante
- Algoritmos precisarem de acesso √† mem√≥ria sequencial

### Use Lista de Adjac√™ncia quando:
- O grafo for esparso (poucas arestas)
- Precisar percorrer vizinhos de um v√©rtice eficientemente
- O grafo tiver muitos v√©rtices
- Precisar adicionar/remover v√©rtices frequentemente

### Use Matriz de Incid√™ncia quando:
- Precisar manipular arestas diretamente
- Trabalhar com multigrafos
- O foco for an√°lise de conex√µes e n√£o de vizinhan√ßa

## üîÑ Convers√£o Entre Representa√ß√µes

√â comum converter de uma representa√ß√£o para outra dependendo do algoritmo a ser aplicado.

```javascript
// Converte matriz de adjac√™ncia para lista de adjac√™ncia
function matrixToList(adjMatrix) {
    const n = adjMatrix.length;
    const adjList = new AdjacencyList();
    
    for (let i = 0; i < n; i++) {
        adjList.addVertex(i);
        for (let j = 0; j < n; j++) {
            if (adjMatrix[i][j] !== 0) {
                adjList.addEdge(i, j, adjMatrix[i][j]);
            }
        }
    }
    
    return adjList;
}

// Converte lista de adjac√™ncia para matriz de adjac√™ncia
function listToMatrix(adjList) {
    const vertices = [...adjList.adjacencyList.keys()];
    const n = vertices.length;
    const vertexToIndex = new Map();
    
    vertices.forEach((v, i) => vertexToIndex.set(v, i));
    
    const adjMatrix = Array(n).fill().map(() => Array(n).fill(0));
    
    for (let [vertex, neighbors] of adjList.adjacencyList.entries()) {
        const i = vertexToIndex.get(vertex);
        
        for (let neighbor of neighbors) {
            let j, weight = 1;
            
            if (typeof neighbor === 'object') {
                j = vertexToIndex.get(neighbor.vertex);
                weight = neighbor.weight;
            } else {
                j = vertexToIndex.get(neighbor);
            }
            
            adjMatrix[i][j] = weight;
        }
    }
    
    return adjMatrix;
}
``` 